---
title: "Classify Real-world Images with Pre-trained Model"
date: "`r Sys.Date()`"
output:
  html_document:
  fig_caption: false
  toc: true
  toc_float:
    collapsed: false
    smooth_scroll: false
  toc_depth: 3
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Import libraries

```{r}
## using pytorch in R via R reticulate

library(reticulate)

torch      = import("torch")
nn         = import("torch.nn") 
optim      = import("torch.optim") 
Variable   = import("torch.autograd")$Variable
np         = import("numpy")

plt        = import("matplotlib")
```


## Load datasets

```{r}
x_train = array(c(3.3, 4.4, 5.5, 6.71, 6.93, 4.168, 
                  9.779, 6.182, 7.59, 2.167, 7.042,
                  10.791, 5.313, 7.997, 3.1), dim = c(15,1))

y_train = array(c(1.7, 2.76, 2.09, 3.19, 1.694, 1.573,
                  3.366, 2.596, 2.53, 1.221, 2.827,
                  3.465, 1.65, 2.904, 1.3), dim = c(15,1))

x_train <- r_to_py(x_train)
y_train <- r_to_py(y_train)

x_train = torch$from_numpy(x_train)   # convert to tensor
y_train = torch$from_numpy(y_train)   # convert to tensor

x_train = x_train$type(torch$FloatTensor)   # make it a a FloatTensor
y_train = y_train$type(torch$FloatTensor)
```


## Linear Regression model
```{r}
# Linear Regression Model. Python class

main = py_run_string(
"
import torch.nn as nn
class LinearRegression(nn.Module):
  def __init__(self):
    super(LinearRegression, self).__init__()
    self.linear = nn.Linear(1, 1)             # input and output is 1 dimension

  def forward(self, x):
    out = self.linear(x)
    return out
")


# build a Linear Rgression model
model <- main$LinearRegression()
```


## Run optimization

```{r}
criterion = nn$MSELoss()
optimizer = optim$SGD(model$parameters(), lr = 1e-4)

num_epochs = 1000

for (epoch in 1:num_epochs) {
    inputs = Variable(x_train)
    target = Variable(y_train)

    # forward
    out = model(inputs)
    loss = criterion(out, target)
    
    # backward
    optimizer$zero_grad()
    loss$backward()
    optimizer$step()
    
    if ( (epoch+1) %% 20 == 0) {
        cat(sprintf("Epoch[%4d/%4d], loss: %6f \n", 
                    epoch+1, num_epochs, loss$data$numpy()))
    }
}

model$eval()
predict = model(Variable(x_train))
predict = predict$data$numpy()
```


## Compare prediction vs actual data

```{r fig.asp=1}

plot(x_train$numpy(), y_train$numpy(), ylim = c(0, 5), col = "red")
lines(x_train$numpy(), predict, col = "blue")
```

## Verify tensors are FloatTensor type

### FloatTensor from R

```{r fig.asp=1}
## using pytorch in R via R reticulate

library(reticulate)

torch      = import("torch")
nn         = import("torch.nn") 
optim      = import("torch.optim") 
Variable   = import("torch.autograd")$Variable
np         = import("numpy")

plt        = import("matplotlib")

x_train = array(c(3.3, 4.4, 5.5, 6.71, 6.93, 4.168, 
                  9.779, 6.182, 7.59, 2.167, 7.042,
                  10.791, 5.313, 7.997, 3.1), dim = c(15,1))

y_train = array(c(1.7, 2.76, 2.09, 3.19, 1.694, 1.573,
                  3.366, 2.596, 2.53, 1.221, 2.827,
                  3.465, 1.65, 2.904, 1.3), dim = c(15,1))

x_train <- r_to_py(x_train)
y_train <- r_to_py(y_train)

x_train = torch$from_numpy(x_train)   # convert to tensor
y_train = torch$from_numpy(y_train)   # convert to tensor

x_train = x_train$type(torch$FloatTensor)   # make it a a FloatTensor
y_train = y_train$type(torch$FloatTensor)

print(x_train)
print(y_train)
```

### FloatTensor from Python

```{python}
import torch
from torch import nn, optim
from torch.autograd import Variable
import numpy as np
import matplotlib.pyplot as plt

x_train = np.array([[3.3], [4.4], [5.5], [6.71], [6.93], [4.168],
                    [9.779], [6.182], [7.59], [2.167], [7.042],
                    [10.791], [5.313], [7.997], [3.1]], dtype=np.float32)

y_train = np.array([[1.7], [2.76], [2.09], [3.19], [1.694], [1.573],
                    [3.366], [2.596], [2.53], [1.221], [2.827],
                    [3.465], [1.65], [2.904], [1.3]], dtype=np.float32)

print(x_train.shape)      
# print(x_train)
                
x_train = torch.from_numpy(x_train)
y_train = torch.from_numpy(y_train)     

print(x_train)
print(y_train)
```

## Verifying the structure of the inputs


```{python}
import torch
from torch import nn, optim
from torch.autograd import Variable
import numpy as np
import matplotlib.pyplot as plt

x_train = np.array([[3.3], [4.4], [5.5], [6.71], [6.93], [4.168],
                    [9.779], [6.182], [7.59], [2.167], [7.042],
                    [10.791], [5.313], [7.997], [3.1]], dtype=np.float32)

y_train = np.array([[1.7], [2.76], [2.09], [3.19], [1.694], [1.573],
                    [3.366], [2.596], [2.53], [1.221], [2.827],
                    [3.465], [1.65], [2.904], [1.3]], dtype=np.float32)

print(x_train.shape)      
# print(x_train)
                
x_train = torch.from_numpy(x_train)
y_train = torch.from_numpy(y_train)  


# Linear Regression Model

class LinearRegression(nn.Module):
    def __init__(self):
        super(LinearRegression, self).__init__()
        self.linear = nn.Linear(1, 1)  # input and output is 1 dimension

    def forward(self, x):
        out = self.linear(x)
        return out


model = LinearRegression()
# 定义loss和优化函数
criterion = nn.MSELoss()
optimizer = optim.SGD(model.parameters(), lr=1e-4)

# 开始训练
num_epochs = 10
# num_epochs = 100
for epoch in range(num_epochs):
    inputs = Variable(x_train)
    target = Variable(y_train)
    
    print(inputs)    
```                    

## sandbox


```{r}
x_train$nelement()    # number of elements in the tensor
```


```{r}
py = import_builtins()
py$enumerate
xx = py$enumerate(x_train)
xit = iterate(xx, simplify = TRUE)


```


